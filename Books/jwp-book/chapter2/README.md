# 2장 문자열 계산기 구현을 통한 테스트와 리팩토링

## 2.1 main() 메소드를 활용한 테스트의 문제점
- 프로덕션 코드의 복잡도가 증가하면 증가할수록, main() 메소드의 복잡도도 증가하고, 결과적으로 main() 메소드를 유지하는데 부담이 된다.
- 프로덕션 코드의 복잡한 로직을 머릿속으로 계산해 결과 값이 정상적으로 출력되는지 일일이 확인해야 하는 번거로움이 있다.

## 2.2 [JUnit](https://junit.org)을 활용해 main() 메소드 문제점 극복
> 책에는 JUnit 4이지만 JUnit 5가 새로 나왔다.
- https://youtu.be/vrUGCv80xqI: 이클립스 활용, JUnit 3 버전 사용방법
- https://youtu.be/tyZMdwT3rIY: JUnit 4 버전 사용방법. 이 절에서는 다루는 모든 내용을 포함하고 있다.

### 2.2.1 한 번에 메소드 하나에만 집중
- 각각의 테스트 메소드를 독립적으로 실행할 수 있기 때문에 현재 내가 구현하고 있는 프로덕션 코드에 집중할 수 있다.

### 2.2.2 결과 값을 눈이 아닌 프로그램을 통해 자동화
- JUnit의 Assert를 사용하기보다 테스트의 의도를 더 쉽게 파악할 수 있는 기능을 제공하는 [AssertJ](https://joel-costigliola.github.io/assertj/)도 많이 사용한다.

## 2.3 문자열 계산기 요구사항 및 실습

### 2.3.1 요구사항
> 문자열 계산기의 요구사항은 전달하는 문자를 구분자로 분리한 후 각 숫자의 합을 구해 반환해야 한다.
- 쉼표(,) 또는 콜론(:)을 구분자로 가지는 문자열을 전달하는 경우 구분자를 기준으로 분리한 각 숫자의 합을 반환한다.<br>예) " " => 0, "1,2" => 3, "1,2,3" => 6, "1,2:3" => 6
- 앞의 기본 구분자(쉼표, 콜론) 외에 커스텀 구분자를 지정할 수 있다. 커스텀 구분자는 문자열 앞부분의 "//"와 "\n" 사이에 위치하는 문자를 커스텀 구분자로 사용한다. 예를 들어 "//;\n1;2;3"과 같이 값을 입력할 경우 커스텀 구분자는 세미콜론(;)이며, 결과 값은 6이 반환되어야 한다.
- 문자열 계산기에 음수를 전달하는 경우 `RuntimeException`으로 예외 처리해야 한다.

### 2.3.3 추가 요구사항
- 메소드가 한 가지 책임만 가지도록 구현한다.
- 인덴트(indent, 들여쓰기) 깊이를 1단계로 유지한다.
- else를 사용하지 마라.

## 2.4 테스트와 리팩토링을 통한 문자열 계산기 구현
### 2.4.1 요구사항을 작은 단위로 나누기
### 2.4.2 모든 단계의 끝은 리팩토링
- 구현 -> 테스트를 통한 결과 확인 -> 리팩토링

## 2.5 추가 학습 자료
### 2.5.1 테스트 주도 개발(Test Driven Development)과 리팩토링
- [테스트 주도 개발: 고품질 쾌속개발을 위한 TDD 실천법과 도구](https://storage.googleapis.com/google-code-archive-downloads/v2/code.google.com/tddbook/TDD_PT.pdf) : TDD가 무엇인지, 등장 배경은 무엇이며, 어떤 효과가 있는지
- [테스트 주도 개발](http://www.yes24.com/Product/Goods/12246033)(Kent Beck 저/김창준, 강규영 역, 인사이트/2004년)
- [리팩토링 : 코드 품질을 개선하는 객체지향 사고법](http://www.yes24.com/Product/Goods/89649360)(마틴 파울러 저/김지원 역, 한빛미디어/2012년)

### 2.5.2 정규 표현식
- [손에 잡히는 정규 표현식](http://www.yes24.com/Product/Goods/3475120)(벤 포터 저/김경수 역, 인사이트(insight), 2009년)
- http://regexr.com/
